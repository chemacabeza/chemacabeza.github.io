---
layout: chapter
title: "Chapter 25: Jobs"
---

# Chapter 25: Jobs


<hr style="width:100%;text-align:center;margin-left:0;margin-bottom:10px">

## Introduction

In Bash, *jobs* represent the commands or processes that you execute from the shell. These jobs can run either in the foreground, where they take over your terminal until completion, or in the background, where they continue to run while freeing your terminal for other tasks. The ability to manage jobs is a powerful feature of Bash that enhances multitasking and productivity on the command line.

Jobs are particularly useful when you need to run long processes without tying up your terminal. For example, downloading large files, compiling code, or running simulations can be sent to the background, allowing you to continue working without interruption. Bash provides a set of intuitive commands and features to control, monitor, and manage these jobs effectively.

Key to understanding jobs in Bash is learning how to start processes in the background, bring them back to the foreground, stop or resume them, and track their progress. Using operators like "`&`" to start background processes and commands like "`jobs`", "`fg`", "`bg`", and "`kill`", you can interact seamlessly with active processes.

Jobs are more than just convenience—they’re a way to boost efficiency and maximize the potential of your command-line environment. Whether you're running multiple scripts, monitoring system tasks, or simply trying to multitask, mastering jobs in Bash will give you greater control and flexibility over your workflows.

## What is a job?

Each time you execute a command in a Bash script or terminal, it is treated as a *job*. Think of a "job" as a more abstract concept than an individual process—it represents a unit of work that the shell manages.

As explored in the chapter on [I/O Redirections]({{ site.url}}/bash-in-depth/0024-IO-Redirections.html), when you run a command like this.

```bash
    command1 | command2 | command3
```

Bash creates three separate processes—one for each command. These processes are linked together, with the standard output of one feeding into the standard input of the next. Despite involving multiple processes, this entire chain is treated as **a single job** by Bash. This abstraction allows the shell to manage the collective work as a unified task, streamlining control and interaction.

## Background jobs and the "`&`" character

By default, jobs and commands run to completion, blocking the shell that invoked them. For instance, consider the following script.

```bash
 1 #!/usr/bin/env bash
 2 #Script: jobs-0001.sh
 3 while true; do
 4     echo "Message"
 5     sleep 3
 6 done
```

This script contains an endless loop that prints the message "`Message`" to the terminal (standard output) every three seconds. Upon executing this script, you will observe the following output.

```txt
$ ./jobs-0001.sh
Message
Message
Message
^C
```

In this scenario, the terminal remains blocked, as the script continuously runs without terminating. To stop its execution, you would need to interrupt it manually using Ctrl+C (Which is the character "`^C`" that appears in the terminal).

However, this behavior can be altered by appending the special character "`&`" at the end of the command, allowing the script to run in the background and freeing up the terminal for other tasks.

```bash
 1 #!/usr/bin/env bash
 2 #Script: jobs-0002.sh
 3 while true; do
 4     echo "Message"
 5     sleep 3
 6 done &
 7 #   ^^^
```

Now when you will execute the previous "`jobs-0002.sh`" script you will get the following in your terminal window.

```txt
$ ./jobs-0002.sh
Message

$ Message
Message
Message
...
```

If you carefully examine the output, you’ll notice two significant changes. First, the terminal is no longer blocked, meaning you can freely use it for other commands. Second, the script continues to print messages to the screen, which can quickly become disruptive and inconvenient as you try to work in the terminal.

I recommend redirecting the standard output of the "`while`" loop to a file to avoid cluttering the terminal. You can achieve this by applying the redirection techniques we explored in the "While Loop Redirection" section of the "I/O Redirections" chapter. Here’s how it looks.

```bash
 1 #!/usr/bin/env bash
 2 #Script: jobs-0003.sh
 3 while true; do
 4     echo "Message"
 5     sleep 3
 6 done >/dev/null &
 7 #   ^^^^^^^^^^^ ^
```

Once you execute the "`jobs-0003.sh`" script your terminal will look like this.

```txt
$ ./jobs-0003.sh

```

You will see that there is no output in your terminal window, but the script is being executed in the background. You can check it by using the command "`ps aux`"<a id="footnote-1-ref" href="#footnote-1" style="font-size:x-small">[1]</a> in the same terminal.

What’s happening here? The standard output is now redirected to "`/dev/null`", effectively discarding it—since this device acts like a black hole for data. As a result, the terminal is no longer cluttered with output, allowing you to continue using it seamlessly.

Whenever you execute Bash scripts or commands with the "`&`" character, two key things occur. First, a child process is created by Bash to execute the specified code. Second, this child process is registered in the shell’s table of active jobs, enabling you to manage it as part of the current session.

## Variable "`$!`"

When you send a job to execute in the background using the "`&`" character, Bash spawns a child process to handle the specified code. This child process is assigned its own unique **Process ID** (PID).

The special variable "`$!`" stores the PID of **the most recently executed background job**, making it easy to reference and manage.

To see this in action, let’s explore an example directly in the terminal.

```txt
$ while true; do echo Message; sleep 3; done >/dev/null &
```

When we hit the Enter key with the previous Bash script we will have something like the following.

```txt
$ while true; do echo Message; sleep 3; done >/dev/null &
[1] 569344
```

When you press Enter, the output displayed includes the job number (1 in this case) and the PID of the newly created process (569344). If you then print the value of the "`$!`" variable, you’ll notice that it matches the same PID.

```txt
$ echo $!
569344
```

When running the same code inside a Bash script, the PID won’t automatically appear on the screen as it does in the terminal. However, the "`$!`" variable will still hold the correct value—the PID of the last job sent to execute in the background.

## Job management commands

So far, we’ve learned how to send jobs to execute as background processes. However, once they’re running in the background, we haven’t explored how to interact with or manage them effectively. In the following subsections, we’ll delve into the various commands available to help you manage and control the jobs you’ve created.

### The "`jobs`" command

The "`jobs`" command in Bash is a powerful tool used to monitor and manage background and suspended jobs in your shell session. It provides a list of currently active jobs along with their statuses, such as *"Running"* or *"Stopped."* Each job is assigned a unique job ID, making it easy to reference and control them. Whether you’re juggling multiple tasks or simply curious about what’s running in the background, the "`jobs`" command is your go-to for keeping track of them.

Let’s say that we execute the following commands in our terminal.

```txt
$ while true; do echo Message; sleep 3; done >/dev/null &
[1] 716199 

$ while true; do echo Message2; sleep 3; done >/dev/null &
[2] 716229

$ while true; do echo Message3; sleep 3; done >/dev/null &
[3] 716255
```

With the previous commands we were able to execute in the background 3 infinite loops that send messages to the device “`/dev/null`”. We could visualize what is happening in the following way.

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0025-Jobs/Bash-Children-Processes.png"/>
</div>

To be able to inspect the shell’s table of active jobs we can use the “`jobs`” command like the following.

```txt
$ jobs
[1]   Running    while true; do echo Message; sleep 3; done > /dev/null &
[2]-  Running    while true; do echo Message2; sleep 3; done > /dev/null &
[3]+  Running    while true; do echo Message3; sleep 3; done > /dev/null &
```

The "`jobs`" command comes equipped with the following options.

| Option | Description |
| :----: | :---- |
| "`-l`" | Lists PIDs on top of the information displayed by default |
| "`-n`" | Lists processes that have changed its status since the last notification |
| "`-p`" | Lists only PIDs |
| "`-r`" | List only jobs that are running | 
| "`-s`" | List only jobs that are stopped |
| "`-x`" | If this option is provided the syntax is as follows "`jobs -x COMMAND [args]`". In this case, all the arguments that look like a *“job specification”* will be replaced with the PID of the referred job. |

You might be wondering what a "job specification" is. In Bash, a job specification is the way the jobs command refers to the processes that make up a job. The syntax for job specifications includes several formats:
* "`%n`": Refers to the job with the number "`n`".
* "`%str`": Refers to the job whose command starts with the string "`str`". If multiple jobs start with the same string, it will fail due to ambiguity.
* "`%?str`": Refers to the job with a command containing the string "`str`". Like "`%str`", it will fail if more than one job matches the criteria.
* "`%%`" or "`%+`": Refers to the job most recently executed in the background or the job most recently suspended from the foreground.
* "`%-`": Refers to the job that was the most recent before the current one ("`%%`").

This system allows you to efficiently target and manage specific jobs using clear and concise references.

## Summary


## References


<hr style="width:100%;text-align:center;margin-left:0;margin-bottom:10px">
<p id="footnote-1" style="font-size:10pt">
1. Check <a href="https://man7.org/linux/man-pages/man1/ps.1.html">https://man7.org/linux/man-pages/man1/ps.1.html</a> for more information.<a href="#footnote-1-ref">&#8617;</a>
</p>

