<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Chapter 12: Arrays and loops | The Engineering Corner</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Chapter 12: Arrays and loops" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chapter 12: Arrays and loops" />
<meta property="og:description" content="Chapter 12: Arrays and loops" />
<link rel="canonical" href="http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html" />
<meta property="og:url" content="http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html" />
<meta property="og:site_name" content="The Engineering Corner" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-11-08T08:37:21+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Chapter 12: Arrays and loops" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-08T08:37:21+01:00","datePublished":"2024-11-08T08:37:21+01:00","description":"Chapter 12: Arrays and loops","headline":"Chapter 12: Arrays and loops","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html"},"url":"http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The Engineering Corner" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">The Engineering Corner</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
						<a class="page-link" href="/about/">About</a>
            <a class="page-link" href="/bash-in-depth/">Bash In Depth</a>
				</div>
      </nav></div>
</header>

<!--header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" href="/">The Engineering Corner</a>
    <nav class="site-nav">
      <label for="nav-trigger">
        <svg aria-hidden="true" class="icon-menu">
          <use xlink:href="#icon-menu"></use>
        </svg>
      </label>
      <div class="trigger">
          
          <a href="/bash-in-depth/">Bash In Depth</a>
      </div>
    </nav>
  </div>
</header-->

<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Chapter 12: Arrays and loops | The Engineering Corner</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Chapter 12: Arrays and loops" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chapter 12: Arrays and loops" />
<meta property="og:description" content="Chapter 12: Arrays and loops" />
<link rel="canonical" href="http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html" />
<meta property="og:url" content="http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html" />
<meta property="og:site_name" content="The Engineering Corner" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-11-08T08:37:21+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Chapter 12: Arrays and loops" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-08T08:37:21+01:00","datePublished":"2024-11-08T08:37:21+01:00","description":"Chapter 12: Arrays and loops","headline":"Chapter 12: Arrays and loops","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html"},"url":"http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html"}</script>
<!-- End Jekyll SEO tag -->

<div class="chapter-content">
  <h1 id="chapter-12-arrays-and-loops">Chapter 12: Arrays and loops</h1>

<h2 id="index">Index</h2>
<ul>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#introduction">Introduction</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#indexed-arrays">Indexed Arrays</a>
    <ul>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#how-do-you-access-items-of-an-indexed-array">How do you access items of an indexed array?</a></li>
    </ul>
  </li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#associative-arrays-aka-hashesmaps">Associative Arrays (a.k.a. Hashes/Maps)</a>
    <ul>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#how-do-you-access-items-of-an-associative-array">How do you access items of an associative array?</a></li>
    </ul>
  </li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#associative-arrays-as-sets">Associative Arrays as Sets</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#operations-with-arrays">Operations with arrays</a>
    <ul>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#first-element-of-the-array">First element of the array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#get-the-whole-content-of-the-array">Get the whole content of the array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#get-the-list-of-indices">Get the list of indices</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#get-the-length-of-the-array">Get the length of the array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#adding-an-element-to-an-array">Adding an element to an array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#delete-element-from-a-given-index">Delete element from a given index</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#delete-element-from-a-given-pattern">Delete element from a given pattern</a>
        <ul>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#shortest-match-from-the-front-of-the-string">Shortest match from the front of the string</a></li>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#longest-match-from-the-front-of-the-string">Longest match from the front of the string</a></li>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#shortest-match-from-the-back-of-the-string">Shortest match from the back of the string</a></li>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#longest-match-from-the-back-of-the-string">Longest match from the back of the string</a></li>
        </ul>
      </li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#substring-replacement-with-regular-expressions">Substring replacement with regular expressions</a>
        <ul>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#replace-first-occurrence">Replace first occurrence</a></li>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#replace-all-occurrences">Replace all occurrences</a></li>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#replace-beginning-occurrences-of-string">Replace beginning occurrences of string</a></li>
          <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#replace-ending-occurrences-of-string">Replace ending occurrences of string</a></li>
        </ul>
      </li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#delete-an-entire-array">Delete an entire array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#consult-the-length-of-the-i-th-element-of-the-array">Consult the length of the i-th element of the array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#how-to-copy-an-array">How to copy an array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#slice-of-an-array">Slice of an array</a></li>
      <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#concatenate-arrays">Concatenate arrays</a></li>
    </ul>
  </li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#for-loop">For-Loop</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#for-loop-c-style">For-Loop (C-style)</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#while-loop">While loop</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#until-loop">Until loop</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#continue-and-break"><code class="language-plaintext highlighter-rouge">continue</code> and <code class="language-plaintext highlighter-rouge">break</code></a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#summary">Summary</a></li>
  <li><a href="http://localhost:4000//bash-in-depth/0012-Arrays-and-loops.html#references">References</a></li>
</ul>

<hr style="width:100%;text-align:center;margin-left:0;margin-bottom:10px;" />

<h2 id="introduction">Introduction</h2>

<p>Bash scripting introduces arrays and loops as essential constructs, facilitating the manipulation and processing of data within scripts. Arrays, the cornerstone of structured data storage in Bash, come in two main types: indexed arrays and associative arrays. Indexed arrays employ numerical indices to represent elements, starting from zero, while associative arrays use user-defined keys for a more versatile and human-readable approach to data organization. This diversity enables scriptwriters to choose the array type that best fits the nature of their data, making Bash scripts adaptable to various scenarios.</p>

<p>In tandem with arrays, Bash incorporates different types of loops, providing the means to iterate over arrays and perform repetitive tasks efficiently. The “<code class="language-plaintext highlighter-rouge">for</code>” loop, a fundamental iteration construct, facilitates the sequential processing of elements within an array or a predefined range of values. Meanwhile, the “<code class="language-plaintext highlighter-rouge">while</code>” and “<code class="language-plaintext highlighter-rouge">until</code>” loops offer conditional iteration, allowing scripts to execute code repeatedly based on specified conditions. This mixture of arrays and loops empowers Bash scripts with the ability to automate complex tasks, process large datasets, and implement dynamic solutions.</p>

<p>As we delve into the intricacies of Bash scripting, we will explore the syntax, usage, and best practices for working with arrays and loops. From basic array declarations to advanced loop structures, understanding these core concepts unlocks the full potential of Bash scripting, enabling scriptwriters to create robust and versatile solutions for various computing tasks and automation scenarios.</p>

<p>Let’s dive in!</p>

<h2 id="indexed-arrays">Indexed Arrays</h2>

<p>An <strong>Indexed Array</strong> is a data structure that associates values to indices (0, 1, 2, etc) and allows you to access those values via indices.</p>

<p>Let’s take a look at a visualization for this kind of array.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/Indexed-array.png" width="500px" />
</div>

<p>How do we declare this kind of array? Well there are 2 ways to declare an indexed array.</p>

<p>The first way is by using initialization declaration, which is assigning a value directly to a variable, like the following.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
</code></pre></div></div>

<p>The second one is by using the “<code class="language-plaintext highlighter-rouge">declare</code>” builtin command that we saw previously with the option “<code class="language-plaintext highlighter-rouge">-a</code>”.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
</code></pre></div></div>

<p>In the next section we are going to learn about associative arrays.</p>

<h3 id="how-do-you-access-items-of-an-indexed-array">How do you access items of an indexed array?</h3>

<p>The way you select an item from an indexed array is as follows.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">echo</span> <span class="s2">"My item: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[</span><span class="nv">$index</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>Where “<code class="language-plaintext highlighter-rouge">$index</code>” is a whole number (for example <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, …).</p>

<h2 id="associative-arrays-aka-hashesmaps">Associative Arrays (a.k.a. Hashes/Maps)</h2>

<p>An <strong>Associative Array</strong> is a data structure that associates values to “<em>keys</em>”. A key can be any random string or number.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/Associative-array.png" width="500px" />
</div>

<p>So, how do we declare an associative array? We use the option “<code class="language-plaintext highlighter-rouge">-A</code>” of the “<code class="language-plaintext highlighter-rouge">declare</code>” builtin command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_MAP</span><span class="o">=(</span> <span class="o">[</span>Madrid]<span class="o">=</span><span class="s2">"Spanish"</span> <span class="o">[</span>London]<span class="o">=</span><span class="s2">"English"</span> <span class="o">[</span>Paris]<span class="o">=</span><span class="s2">"French"</span><span class="o">)</span>
</code></pre></div></div>

<p>This is <strong>the only valid way</strong> to declare an associative array.</p>

<p>If you try to declare the previous associative array without “<code class="language-plaintext highlighter-rouge">declare -A</code>” you will be surprised. Let’s see it with an example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: bad_associative_array.sh</span>
 3 <span class="nv">MY_MAP</span><span class="o">=(</span> <span class="o">[</span>Madrid]<span class="o">=</span><span class="s2">"Spanish"</span> <span class="o">[</span>London]<span class="o">=</span><span class="s2">"English"</span> <span class="o">[</span>Paris]<span class="o">=</span><span class="s2">"French"</span><span class="o">)</span>
 4 <span class="nb">declare</span> <span class="nt">-p</span> MY_MAP
</code></pre></div></div>

<p>When you run the previous script you will the following result in your terminal.</p>

<pre><code class="language-txt">$ ./bad_associative_array.sh
declare -a MY_MAP=([0]="French")
</code></pre>

<p>As you can see without using “<code class="language-plaintext highlighter-rouge">declare -A</code>” the variable “<code class="language-plaintext highlighter-rouge">MY_MAP</code>” is treated like an indexed array. This is because the keys “<code class="language-plaintext highlighter-rouge">Madrid</code>”, “<code class="language-plaintext highlighter-rouge">London</code>” and “<code class="language-plaintext highlighter-rouge">Paris</code>” are treated as variables and as they do not exist, Bash assumes the value “<code class="language-plaintext highlighter-rouge">0</code>” for all of them.</p>

<p>This means that the values “<code class="language-plaintext highlighter-rouge">Spanish</code>”, “<code class="language-plaintext highlighter-rouge">English</code>” and “<code class="language-plaintext highlighter-rouge">French</code>” are associated to the same key/index (“<code class="language-plaintext highlighter-rouge">0</code>” in our case) which will cause that the different values will be overriding the previous value, leaving the value “<code class="language-plaintext highlighter-rouge">French</code>” as the last value overriding the content of the key/index “<code class="language-plaintext highlighter-rouge">0</code>”.</p>

<p>Now, if we declare one of the keys as a variable and assign a whole number (0, 1, 2, etc) the result will change. Let’s see it with an example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: bad_associative_array_2.sh</span>
 3 <span class="nv">Madrid</span><span class="o">=</span>20
 4 <span class="nv">MY_MAP</span><span class="o">=(</span> <span class="o">[</span>Madrid]<span class="o">=</span><span class="s2">"Spanish"</span> <span class="o">[</span>London]<span class="o">=</span><span class="s2">"English"</span> <span class="o">[</span>Paris]<span class="o">=</span><span class="s2">"French"</span><span class="o">)</span>
 5 <span class="nb">declare</span> <span class="nt">-p</span> MY_MAP
</code></pre></div></div>

<p>When you run the previous script you will have now the following result.</p>

<pre><code class="language-txt">$ ./bad_associative_array_2.sh
declare -a MY_MAP=([0]="French" [20]="Spanish")
</code></pre>

<p>Now, rather than having one single element in the array there are <strong>two</strong>. One associated with index “<code class="language-plaintext highlighter-rouge">0</code>” and another one associated with index “<code class="language-plaintext highlighter-rouge">20</code>”.</p>

<h3 id="how-do-you-access-items-of-an-associative-array">How do you access items of an associative array?</h3>

<p>The way you select an item from an associative array is as follows.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">echo</span> <span class="s2">"My item: </span><span class="k">${</span><span class="nv">MY_MAP</span><span class="p">[</span><span class="nv">$key</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>Where “<code class="language-plaintext highlighter-rouge">$key</code>” is one of the keys stores in the associative array (something like “<code class="language-plaintext highlighter-rouge">Madrid</code>”, “<code class="language-plaintext highlighter-rouge">London</code>” or “<code class="language-plaintext highlighter-rouge">Paris</code>” from the previous example).</p>

<h2 id="associative-arrays-as-sets">Associative Arrays as Sets</h2>

<p>In the previous sections we learnt that an associative array is used to map a string of characters to some value. This is known in software engineering as a “<em>Map</em>”, “<em>Dictionary</em>” or (as is known in Bash) “<em>Associative arrays</em>”.</p>

<p>In software engineering there is another data structure called “<em>Set</em>”. A set is a data structure that contains unique values without a particular order.</p>

<p>Bash, technically, does not provide the data structure “Set” but we can use an associative array to simulate the same behavior.</p>

<p>The idea is to create an associative array that has as keys the unique information you want to store and “<code class="language-plaintext highlighter-rouge">1</code>” as value. That’s it!</p>

<p>Let’s see how it works with an example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_as_set.sh</span>
 3 <span class="c"># Declaring set with 3 cities</span>
 4 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">CITIES</span><span class="o">=(</span>
 5  <span class="o">[</span>London]<span class="o">=</span>1
 6  <span class="o">[</span>Paris]<span class="o">=</span>1
 7  <span class="o">[</span>Madrid]<span class="o">=</span>1
 8 <span class="o">)</span>
 9 <span class="c"># Checking for a city inside the Set</span>
10 <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="k">${</span><span class="nv">CITIES</span><span class="p">[London]</span><span class="k">}</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
</span>11     <span class="nb">echo</span> <span class="s2">"London is in the set"</span> <span class="c"># This will be printed</span>
12 <span class="k">else
</span>13     <span class="nb">echo</span> <span class="s2">"London is NOT in the set"</span>
14 <span class="k">fi
</span>15 <span class="c"># Checking for a city that is not in the Set</span>
16 <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="k">${</span><span class="nv">CITIES</span><span class="p">[Seville]</span><span class="k">}</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
</span>17     <span class="nb">echo</span> <span class="s2">"Seville is in the set"</span>
18 <span class="k">else
</span>19     <span class="nb">echo</span> <span class="s2">"Seville is NOT in the set"</span> <span class="c"># This will be printed</span>
20 <span class="k">fi</span>
</code></pre></div></div>

<p>In this simple case we are using the option “<code class="language-plaintext highlighter-rouge">-n</code>” of test which will return true if the string is not empty. When we run the previous script we get the following result.</p>

<pre><code class="language-txt">$ ./array_as_set.sh
London is in the set
Seville is NOT in the set
</code></pre>

<p>Now that we have learnt how to declare indexed and associative arrays we are going to dive on the operations we can do on them in the next section.</p>

<h2 id="operations-with-arrays">Operations with arrays</h2>

<p>In this section we are going to assume that we have declared an array called “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>”.</p>

<p>Once the array is declared, what can we do with it? In the next subsections we will have a short view of what we can do with some examples.</p>

<h3 id="first-element-of-the-array">First element of the array</h3>

<p>In the case of an indexed array referring to the variable “<code class="language-plaintext highlighter-rouge">$MY_ARRAY</code>” will show the first element of the array itself.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_index_first.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"First item: </span><span class="nv">$MY_ARRAY</span><span class="s2">"</span>
</code></pre></div></div>

<p>When we execute the previous script, you will get the following in your terminal.</p>

<pre><code class="language-txt">$ ./array_index_first.sh
First item: value1
</code></pre>

<p>In the case of an associative array referring to the variable “<code class="language-plaintext highlighter-rouge">$MY_ARRAY</code>” will not show anything as associative arrays are not sorted.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_associative_first.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 <span class="nb">echo</span> <span class="s2">"First item: </span><span class="nv">$MY_ARRAY</span><span class="s2">"</span>
</code></pre></div></div>

<p>As you will see in the following execution of the script, “<code class="language-plaintext highlighter-rouge">$MY_ARRAY</code>” returns empty.</p>

<pre><code class="language-txt">$ ./array_associative_first.sh
First item:
</code></pre>

<p>It returns empty <strong>because Bash does not directly support printing an entire associative array by just referencing its name</strong> like you would with a regular variable. Associative arrays in Bash require you to access individual elements or loop through the keys.</p>

<p>In the next section we will see how to get the whole content of the array.</p>

<h3 id="get-the-whole-content-of-the-array">Get the whole content of the array</h3>

<p>There are two ways to get the whole content of an indexed array or the values of an associative array. Which are “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” and “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>”.</p>

<p>The difference is that “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” will display the elements of the indexed array (or the values of the associative array) as <strong>a single string</strong>, while “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>” will display the same ones quoted separately.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_content.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content 1: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="nb">echo</span> <span class="s2">"Content 2: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When we execute the previous script we get the following result in the terminal.</p>

<pre><code class="language-txt">$ ./index_array_content.sh
Content 1: value1 value2 value3
Content 2: value1 value2 value3
</code></pre>
<p>The execution does not show us the difference between “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” and “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>” but don’t worry we will see it more clearly when we get into the different kinds of loops, just keep this in mind.</p>

<p>Something similar happens when we try to use “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” and “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>” with associative arrays.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: associative_array_content.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 <span class="nb">echo</span> <span class="s2">"Content-1: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="nb">echo</span> <span class="s2">"Content-2: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you run the previous script you will get the following result in your terminal.</p>

<pre><code class="language-txt">$ ./associative_array_content.sh
Content-1: value2 value3 value1
Content-2: value2 value3 value1
</code></pre>

<p>Same as with indexed arrays, we will come back to this when we will talk about loops.</p>

<p>In the next section we will see how to get the list of indices for both indexed and associative arrays.</p>

<h3 id="get-the-list-of-indices">Get the list of indices</h3>

<p>The way to get the indices of both indexed and associative arrays is by using “<code class="language-plaintext highlighter-rouge">${!MY_ARRAY[@]}</code>”.</p>

<p>If you use it with an indexed array it will return the indices that contain a value.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_indices.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Indices: </span><span class="k">${</span><span class="p">!MY_ARRAY[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you execute the previous script you will get the following result in your terminal.</p>

<pre><code class="language-txt">$ ./index_array_indices.sh
Indices: 0 1 2
</code></pre>

<p>If you use it with an associative array it will return the keys.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: associative_array_indices.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 <span class="nb">echo</span> <span class="s2">"Indices: </span><span class="k">${</span><span class="p">!MY_ARRAY[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you execute the previous script you will get the list of keys unsorted.</p>

<pre><code class="language-txt">$ ./associative_array_indices.sh
Indices: key2 key3 key1
</code></pre>

<p>In the next section we will learn how to get the length of the array.</p>

<h3 id="get-the-length-of-the-array">Get the length of the array</h3>

<p>To be able get the length of an array (both indexed and associative) you can use either “<code class="language-plaintext highlighter-rouge">${#MY_ARRAY[*]}</code>” or “<code class="language-plaintext highlighter-rouge">${#MY_ARRAY[@]}</code>”, <strong>both expressions are equivalent</strong>.</p>

<p>Let’s see it with a couple of examples.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_length.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Length-1: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="nb">echo</span> <span class="s2">"Length-2: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you run the previous script for indexed arrays you will the following result in your terminal.</p>

<pre><code class="language-txt">$ ./index_array_length.sh
Length-1: 3
Length-2: 3
</code></pre>

<p>And now an example for associative arrays.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: associative_array_length.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 <span class="nb">echo</span> <span class="s2">"Length-1: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="nb">echo</span> <span class="s2">"Length-2: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you execute the previous script you get the following in your terminal.</p>

<pre><code class="language-txt">$ ./associative_array_length.sh
Length-1: 3
Length-2: 3
</code></pre>

<p>In the next section we are going to see how to add an element to an array.</p>

<h3 id="adding-an-element-to-an-array">Adding an element to an array</h3>

<p>In order to add an additional element to an array we can do it by using the following form.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/Add-Item-To-Array.png" width="550px" />
</div>

<p>As you can see the only difference on adding a new element to an indexed array or an associative array is including the key in the associative array.</p>

<p>For example, for an indexed array we would proceed as follows.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_add.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Elements: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 MY_ARRAY+<span class="o">=(</span><span class="s2">"value4"</span><span class="o">)</span>
 6 <span class="nb">echo</span> <span class="s2">"Elements: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you run the previous script you will get the following in the terminal.</p>

<pre><code class="language-txt">$ ./index_array_add.sh
Elements: value1 value2 value3
Elements: value1 value2 value3 value4
</code></pre>

<p>Where you can see the new value (“<code class="language-plaintext highlighter-rouge">value4</code>”) added to the end of the array.</p>

<p>In the case of an associative array we would do the following.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: associative_array_add.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 MY_ARRAY+<span class="o">=([</span>key4]<span class="o">=</span><span class="s2">"value4"</span><span class="o">)</span>
 9 <span class="nb">declare</span> <span class="nt">-p</span> MY_ARRAY
</code></pre></div></div>

<p>When you run the previous script you will get the following result in your terminal.</p>

<pre><code class="language-txt">$ ./associative_array_add.sh
declare -A MY_ARRAY=([key4]="value4" [key2]="value2" [key3]="value3" [key1]="value1" )
</code></pre>

<p>In the result you can cleary see that the a new value was added to the associative array with key “<code class="language-plaintext highlighter-rouge">key4</code>” and value “<code class="language-plaintext highlighter-rouge">value4</code>”.</p>

<p>Something to notice is that for associative arrays you can add elements by using “<code class="language-plaintext highlighter-rouge">MY_ARRAY[Key]=Value</code>”. This means that we could rewrite the last script as the following and we would get the exact same result.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: associative_array_add.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 MY_ARRAY[<span class="s2">"key4"</span><span class="o">]=</span><span class="s2">"value4"</span>
 9 <span class="nb">declare</span> <span class="nt">-p</span> MY_ARRAY
</code></pre></div></div>

<p>In the next section we are going to learn how to delete specific elements from arrays.</p>

<h3 id="delete-element-from-a-given-index">Delete element from a given index</h3>

<p>There are a couple of ways to delete elements from an array (either indexed or associative). The one we are exploring in this section is by using the index of the element we want to delete.</p>

<p>If you remember the indices are different in both indexed and associative arrays.</p>

<p>In indexed arrays the indices are whole numbers (0, 1, 2, etc) while in associative arrays the indices are the keys (“<code class="language-plaintext highlighter-rouge">key1</code>”, “<code class="language-plaintext highlighter-rouge">key2</code>”, “<code class="language-plaintext highlighter-rouge">key3</code>” in our previous examples).</p>

<p>In both types of array we will have to use the following to delete elements.</p>

<div style="text-align:center">
<img src="/assets/bash-in-depth/0012-Arrays-and-loops/Unset-Item-From-Array.png" width="550px" />
</div>

<p>In the following example we are deleting the second element (index “<code class="language-plaintext highlighter-rouge">1</code>”) of the array.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_delete.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"value1"</span> <span class="s2">"value2"</span> <span class="s2">"value3"</span><span class="o">)</span>
 4 <span class="c"># Deleting second item of the array</span>
 5 <span class="nb">unset </span>MY_ARRAY[1]
 6 <span class="c"># Printing the whole content of the array</span>
 7 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When we execute the previous script you will see that “<code class="language-plaintext highlighter-rouge">value2</code>” is no longer in the array.</p>

<pre><code class="language-txt">$ ./index_array_delete.sh
Content: value1 value3
</code></pre>

<p>In the case of an associative array, as it was mentioned before, we need to use the key of the entry we want to delete. In the following example we will remove the entry whose key is “<code class="language-plaintext highlighter-rouge">key2</code>”.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: associative_array_delete.sh</span>
 3 <span class="nb">declare</span> <span class="nt">-A</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>
 4     <span class="o">[</span>key1]<span class="o">=</span><span class="s2">"value1"</span>
 5     <span class="o">[</span>key2]<span class="o">=</span><span class="s2">"value2"</span>
 6     <span class="o">[</span>key3]<span class="o">=</span><span class="s2">"value3"</span>
 7 <span class="o">)</span>
 8 <span class="nb">unset </span>MY_ARRAY[key2]
 9 <span class="nb">declare</span> <span class="nt">-p</span> MY_ARRAY
</code></pre></div></div>

<p>When we execute the previous script you will see that the element whose key is “<code class="language-plaintext highlighter-rouge">key2</code>” is no longer in the associative array.</p>

<pre><code class="language-txt">$ ./associative_array_delete.sh
declare -A MY_ARRAY=([key3]="value3" [key1]="value1" )
</code></pre>

<p>In the next section we will learn how to delete elements based on a pattern.</p>

<h3 id="delete-element-from-a-given-pattern">Delete element from a given pattern</h3>

<p>In the previous section we learnt how to delete elements from an array, but we needed to know beforehand what the index/key of the element was.</p>

<p>In this section we are going to learn how to delete elements based on a “<em>pattern</em>”. It will be like saying “<em>Please delete the elements that look like this pattern</em>”.</p>

<p>The generic form that we will use is as follows.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/Generic-Form-Delete-From-Pattern.png" width="450px" />
</div>

<p>Those 4 dots will be replaced with some syntax that will do pattern matching to find the elements before removing them. There are several ways to remove an element from an array and are the following:</p>
<ul>
  <li>Shortest match from the front of the string</li>
  <li>Longest match from the front of the string</li>
  <li>Shortest match from the back of the string</li>
  <li>Longest match from the back of the string</li>
</ul>

<h4 id="shortest-match-from-the-front-of-the-string"><b>Shortest match from the front of the string</b></h4>

<p>The first approach is by using “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]#&lt;pattern&gt;}</code>”. This way is going to search for the elements in the array that match the pattern given the <strong>shortest</strong> starting from the <strong>front of the string</strong>.</p>

<p>The previous statement means that once you provide the pattern, Bash will go element by element and, for each element, will try to match the pattern provided starting from the beginning of the string. Then it will remove the pattern found once it finds the shortest match.</p>

<p>Let’s see an example to better understand how it works.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_delete_pattern_front_shortest.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Shortest match from front of string</span>
 6 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*</span><span class="k">}</span><span class="s2">"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*ee</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>On line 3 we declare an array with six elements. On line 4 we display the content of the array. Then (the interesting part) on lines 6 and 7 we use two different patterns.</p>

<p>The first pattern (“<code class="language-plaintext highlighter-rouge">t*</code>”) means that there is a need to match the shortest string that starts with the character “<code class="language-plaintext highlighter-rouge">t</code>” and has zero or more characters after it. In our case, there are two strings of “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” that start with the character “<code class="language-plaintext highlighter-rouge">t</code>”, which are the second and the third element whose values are “<code class="language-plaintext highlighter-rouge">two</code>” and “<code class="language-plaintext highlighter-rouge">three</code>”, respectively. And the shortest string matching that pattern is “<code class="language-plaintext highlighter-rouge">t</code>”.</p>

<p>This means that Bash will remove just the character “<code class="language-plaintext highlighter-rouge">t</code>” from both elements of the array.</p>

<p>The second pattern (“<code class="language-plaintext highlighter-rouge">t*ee</code>”) means that there is a need to match the shortest string that starts with the character “<code class="language-plaintext highlighter-rouge">t</code>”, has zero or more characters after it and ends with the characters “<code class="language-plaintext highlighter-rouge">ee</code>”. Same as in the previous patterns, the only string of “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” that matches that pattern is the third element. In this case the pattern will match the whole string.</p>

<p>This means that Bash will remove the whole element of the array.</p>

<p>When we run the previous script you will see the following output in your terminal.</p>

<pre><code class="language-txt">$ ./index_array_delete_pattern.sh
Content: one two three four five six
${MY_ARRAY[@]#t*}: one wo hree four five six
${MY_ARRAY[@]#t*ee}: one two  four five six
</code></pre>

<p>As you can see in the execution of the script, the first pattern removes only one character of a couple of elements of the array, while the first pattern removes a whole element that matches the pattern.</p>

<p>In the next section we will match the longest pattern starting from the front.</p>

<h4 id="longest-match-from-the-front-of-the-string"><b>Longest match from the front of the string</b></h4>

<p>The second approach is by using “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]##&lt;pattern&gt;}</code>”. This way is going to search for the elements in the array that match the pattern given the <strong>longest</strong> starting from the <strong>front of the string</strong>.</p>

<p>The previous statement means that once you provide the pattern, Bash will go element by element and, for each element, will try to match the pattern provided starting from the beginning of the string. Then it will remove the pattern found once it finds the longest match.</p>

<p>Let’s write another script to see how it works. In the next script we left the content of the previous script and added the new things of this section.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_delete_pattern.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Shortest match from front of string</span>
 6 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*</span><span class="k">}</span><span class="s2">"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*ee</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="c"># Longest match from the front of string</span>
 9 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n\$</span><span class="s2">{MY_ARRAY[@]##t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]##t*</span><span class="k">}</span><span class="s2">"</span>
10 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]##t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]##t*ee</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>In this case we have added from line 8 to line 10. Let’s see what happens when we run the script.</p>

<pre><code class="language-txt">$ ./index_array_delete_pattern.sh
Content: one two three four five six
${MY_ARRAY[@]#t*}: one wo hree four five six
${MY_ARRAY[@]#t*ee}: one two  four five six

${MY_ARRAY[@]##t*}: one   four five six
${MY_ARRAY[@]##t*ee}: one two  four five six
</code></pre>

<p>As you can see from the new execution, the first pattern (“<code class="language-plaintext highlighter-rouge">t*</code>”) will match the longest string of characters that contain the pattern, which happens to be elements with values “<code class="language-plaintext highlighter-rouge">two</code>” and “<code class="language-plaintext highlighter-rouge">three</code>”. Bash will remove those two elements from the array.</p>

<p>The second pattern (“<code class="language-plaintext highlighter-rouge">t*ee</code>”), however, as it’s more specific than the previous one will only match the element with value “<code class="language-plaintext highlighter-rouge">three</code>”. In this case, Bash will remove one single element from the array.</p>

<p>In the next section we will match the shortest pattern starting from the back.</p>

<h4 id="shortest-match-from-the-back-of-the-string"><b>Shortest match from the back of the string</b></h4>

<p>The third approach is by using “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]%&lt;pattern&gt;}</code>”. This way is going to search for the elements in the array that match the pattern given the <strong>shortest</strong> starting from the <strong>back of the string</strong>.</p>

<p>The previous statement means that once you provide the pattern, Bash will go element by element and, for each element, will try to match the pattern provided starting from the end of the string. Then it will remove the pattern found once it finds the shortest match.</p>

<p>Let’s write another script that shows this way of removing parts of the items and that is comparing them to the previous ways that we saw.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_delete_pattern_back_shortest.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Shortest match from front of string</span>
 6 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*</span><span class="k">}</span><span class="s2">"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*ee</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="c"># Longest match from the front of string</span>
 9 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n\$</span><span class="s2">{MY_ARRAY[@]##t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]##t*</span><span class="k">}</span><span class="s2">"</span>
10 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]##t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]##t*ee</span><span class="k">}</span><span class="s2">"</span>
11 <span class="c"># Shortest match from the back of string</span>
12 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n\$</span><span class="s2">{MY_ARRAY[@]%*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]%*ee</span><span class="k">}</span><span class="s2">"</span>
13 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]%t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]%t*ee</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>We added lines 11 to 13. When we run the script the following appears in your terminal window.</p>

<pre><code class="language-txt">$ ./index_array_delete_pattern_back_shortest.sh
Content: one two three four five six
${MY_ARRAY[@]#t*}: one wo hree four five six
${MY_ARRAY[@]#t*ee}: one two  four five six

${MY_ARRAY[@]##t*}: one   four five six
${MY_ARRAY[@]##t*ee}: one two  four five six

${MY_ARRAY[@]%*ee}: one two thr four five six
${MY_ARRAY[@]%t*ee}: one two  four five six
</code></pre>

<p>In the execution you can see that the first pattern (“<code class="language-plaintext highlighter-rouge">*ee</code>”) matches the shortest string ending in “<code class="language-plaintext highlighter-rouge">ee</code>” which happens to be the last two letters of the third element of the array (with value “<code class="language-plaintext highlighter-rouge">three</code>”).</p>

<p>In the case of the second pattern (“<code class="language-plaintext highlighter-rouge">t*ee</code>”) the pattern will match the whole string of the third element. The result will be that the element in question will be removed.</p>

<p>In the next section we will match the longest pattern starting from the back.</p>

<h4 id="longest-match-from-the-back-of-the-string"><b>Longest match from the back of the string</b></h4>

<p>The third approach is by using “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]%%&lt;pattern&gt;}</code>”. This way is going to search for the elements in the array that match the pattern given the <strong>longest</strong> starting from the <strong>back of the string</strong>.</p>

<p>The previous statement means that once you provide the pattern, Bash will go element by element and, for each element, will try to match the pattern provided starting from the end of the string. Then it will remove the pattern found once it finds the longest match.</p>

<p>Same as in the previous cases we will write a new script comparing this way of deleting items (or parts of items) of arrays to the previous ones.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_delete_pattern_back_longest.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Shortest match from front of string</span>
 6 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*</span><span class="k">}</span><span class="s2">"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]#t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]#t*ee</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="c"># Longest match from the front of string</span>
 9 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n\$</span><span class="s2">{MY_ARRAY[@]##t*}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]##t*</span><span class="k">}</span><span class="s2">"</span>
10 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]##t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]##t*ee</span><span class="k">}</span><span class="s2">"</span>
11 <span class="c"># Shortest match from the back of string</span>
12 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n\$</span><span class="s2">{MY_ARRAY[@]%*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]%*ee</span><span class="k">}</span><span class="s2">"</span>
13 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]%t*ee}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]%t*ee</span><span class="k">}</span><span class="s2">"</span>
14 <span class="c"># Longest match from the back of string</span>
15 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n\$</span><span class="s2">{MY_ARRAY[@]%%*e}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]%%*e</span><span class="k">}</span><span class="s2">"</span>
16 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]%%f*e}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]%%f*e</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>We added lines 13 to 16. When we run the script the following appears in your terminal window.</p>

<pre><code class="language-txt">$ ./index_array_delete_pattern_back_longest.sh
Content: one two three four five six
${MY_ARRAY[@]#t*}: one wo hree four five six
${MY_ARRAY[@]#t*ee}: one two  four five six

${MY_ARRAY[@]##t*}: one   four five six
${MY_ARRAY[@]##t*ee}: one two  four five six

${MY_ARRAY[@]%*ee}: one two thr four five six
${MY_ARRAY[@]%t*ee}: one two  four five six

${MY_ARRAY[@]%%*e}:  two  four  six
${MY_ARRAY[@]%%f*e}: one two three four  six
</code></pre>

<p>In the execution you can see that with the first pattern (“<code class="language-plaintext highlighter-rouge">*e</code>”), half of the elements in the array were removed. This is because the elements “<code class="language-plaintext highlighter-rouge">on</code><strong>e</strong>”, “<code class="language-plaintext highlighter-rouge">thre</code><strong>e</strong>” and “<code class="language-plaintext highlighter-rouge">fiv</code><strong>e</strong>” match the pattern of having one single character “<code class="language-plaintext highlighter-rouge">e</code>” at the very end of the string.</p>

<p>In the case of the second pattern (“<code class="language-plaintext highlighter-rouge">f*e</code>”), there is only one element that starts with the “<code class="language-plaintext highlighter-rouge">f</code>” character, has zero or more characters after it and ends with the character “<code class="language-plaintext highlighter-rouge">e</code>”.</p>

<p>Although in the previous sections we have been using indexed arrays, this way to delete elements can be applied as well to the values of an associative array<a id="footnote-1-ref" href="#footnote-1" style="font-size:x-small">[1]</a>.</p>

<h3 id="substring-replacement-with-regular-expressions">Substring replacement with regular expressions</h3>

<p>In the previous section we learnt several ways to delete elements from an array using regular expressions. We also learnt that in some cases we could remove part of the string.</p>

<p>In this section we are going to learn how to replace parts of the string (and even delete it) based on a regular expression.</p>

<p>Same as in the previous section we will be focused on indexed arrays, but the same can be applied to the values of associative arrays.</p>

<p>There are 4 ways to replace with regular expressions, which are:</p>
<ul>
  <li>Replace first occurrence</li>
  <li>Replace all occurrences</li>
  <li>Replace beginning occurrences of string</li>
  <li>Replace ending occurrences of string</li>
</ul>

<h4 id="replace-first-occurrence"><b>Replace first occurrence</b></h4>

<p>To be able to replace the <strong>first occurrence</strong> of a pattern in a string element of an array we need to use the following syntax: “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]/&lt;pattern&gt;/&lt;replacement&gt;}</code>”.</p>

<p>Let’s give it a try with the following script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_replace_pattern_first.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Replace first occurrence</span>
 6 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace first occurrence"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e/X</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e*/X</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>In the previous script we are using two different patterns. When we run the script the following is printed in the terminal window.</p>

<pre><code class="language-txt">$ ./index_array_replace_pattern_first.sh
Content: one two three four five six

Replace first occurrence
${MY_ARRAY[@]/e/X}: onX two thrXe four fivX six
${MY_ARRAY[@]/e*/X}: onX two thrX four fivX six
</code></pre>

<p>The first pattern (“<code class="language-plaintext highlighter-rouge">e</code>”), which is in line 7 of the script, will replace the first occurrence of the character “<code class="language-plaintext highlighter-rouge">e</code>” with the character “<code class="language-plaintext highlighter-rouge">X</code>” starting from the beginning of the string (from the left). This will affect one single character in several elements of the array.</p>

<p>The second pattern (“<code class="language-plaintext highlighter-rouge">e*</code>”), found in line 8 of the script, will replace the first occurrence of the pattern with the character “<code class="language-plaintext highlighter-rouge">X</code>” starting from the beginning of the string. In this case, as the pattern contains the character “<code class="language-plaintext highlighter-rouge">*</code>” it will match the rest of the string starting from the first character “<code class="language-plaintext highlighter-rouge">e</code>”. This will affect more than a single character in several elements of the array.</p>

<p>In the next section we will learn how to replace all occurrences given a pattern.</p>

<h4 id="replace-all-occurrences"><b>Replace all occurrences</b></h4>

<p>To be able to replace <strong>all occurrences</strong> of a pattern in a string element of an array we need to use the following syntax: “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]/&lt;pattern&gt;/&lt;replacement&gt;}</code>”.</p>

<p>Let’s write another script so that we can see how this way of replacement is different from the previous one.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_replace_pattern_all.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Replace first occurrence</span>
 6 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace first occurrence"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e/X</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e*/X</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="c"># Replace all occurrences</span>
10 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace all occurrences"</span>
11 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/X</span><span class="k">}</span><span class="s2">"</span>
12 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e*/X</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>We added lines 9 to 12 to our script. We are using the same two patterns as before.</p>

<p>With the first pattern (“<code class="language-plaintext highlighter-rouge">e</code>”) on line 11, Bash will replace every single instance of the pattern with the character “<code class="language-plaintext highlighter-rouge">X</code>”. This means every single character “<code class="language-plaintext highlighter-rouge">e</code>” will be replaced with the character “<code class="language-plaintext highlighter-rouge">X</code>”.</p>

<p>With the second pattern (“<code class="language-plaintext highlighter-rouge">e*</code>”) on line 12, Bash will replace every single instance of the pattern with the character “<code class="language-plaintext highlighter-rouge">X</code>”. In this case, every sequence of characters that starts with the character “<code class="language-plaintext highlighter-rouge">e</code>” will be replaced with a single character “<code class="language-plaintext highlighter-rouge">X</code>”.</p>

<p>When you run the previous script you will get the following result in your terminal window.</p>

<pre><code class="language-txt">$ ./index_array_replace_pattern_all.sh
Content: one two three four five six

Replace first occurrence
${MY_ARRAY[@]/e/X}: onX two thrXe four fivX six
${MY_ARRAY[@]/e*/X}: onX two thrX four fivX six

Replace all occurrences
${MY_ARRAY[@]//e/X}: onX two thrXX four fivX six
${MY_ARRAY[@]//e*/X}: onX two thrX four fivX six
</code></pre>

<p>A special use case of this syntax is that we can use it to remove elements from the array as well. To be able to do this we need to adjust the pattern to match the elements we want to remove and use an empty string as replacement.</p>

<p>Let’s see how it is done with the following script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_replace_pattern_all_delete.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Replace first occurrence</span>
 6 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace first occurrence"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e/X</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e*/X</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="c"># Replace all occurrences</span>
10 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace all occurrences"</span>
11 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/X</span><span class="k">}</span><span class="s2">"</span>
12 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e*/X</span><span class="k">}</span><span class="s2">"</span>
13 <span class="c"># Removal of elements</span>
14 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Removal of elements"</span>
15 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/</span><span class="k">}</span><span class="s2">"</span>
16 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//f*/}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//f*/</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>If you pay attention, this script is the same as before but we added lines from 13 to 16.</p>

<p>The first pattern (“<code class="language-plaintext highlighter-rouge">e</code>”) in line 15 will remove individual characters of the elements in the array, while the second pattern (“<code class="language-plaintext highlighter-rouge">f*</code>”) in line 16 will remove two elements of the array.</p>

<p>If you run the previous script you will see the following result in your terminal window.</p>

<pre><code class="language-txt">$ ./index_array_replace_pattern_all_delete.sh
Content: one two three four five six

Replace first occurrence
${MY_ARRAY[@]/e/X}: onX two thrXe four fivX six
${MY_ARRAY[@]/e*/X}: onX two thrX four fivX six

Replace all occurrences
${MY_ARRAY[@]//e/X}: onX two thrXX four fivX six
${MY_ARRAY[@]//e*/X}: onX two thrX four fivX six

Removal of elements
${MY_ARRAY[@]//e/}: on two thr four fiv six
${MY_ARRAY[@]//f*/}: one two three   six
</code></pre>

<p>In the next two sections we will learn how to do replacements targeting specifically the beginning and the ending of the string.</p>

<h4 id="replace-beginning-occurrences-of-string"><b>Replace beginning occurrences of string</b></h4>

<p>To be able to replace occurrences at the beginning of a string we need to use the following syntax: “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]/#&lt;pattern&gt;/&lt;replacement&gt;}</code>”.</p>

<p>What will happen is that Bash will go element by element and will replace the substring that matches the pattern provided, that is <strong>at the beginning of the string</strong>, with the replacement provided.</p>

<p>Let’s see how it works with an example by modifying our previous script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_replace_pattern_front_beginning.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Replace first occurrence</span>
 6 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace first occurrence"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e/X</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e*/X</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="c"># Replace all occurrences</span>
10 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace all occurrences"</span>
11 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/X</span><span class="k">}</span><span class="s2">"</span>
12 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e*/X</span><span class="k">}</span><span class="s2">"</span>
13 <span class="c"># Removal of elements</span>
14 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Removal of elements"</span>
15 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/</span><span class="k">}</span><span class="s2">"</span>
16 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//f*/}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//f*/</span><span class="k">}</span><span class="s2">"</span>
17 <span class="c"># Replace front-end occurrences of string</span>
18 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace front-end occurrences of string"</span>
19 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/#e/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/#e/XY</span><span class="k">}</span><span class="s2">"</span>
20 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/#f/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/#f/XY</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>In this case we have added lines 17 to 20 to our script. In line 19 we are trying to replace the character “<code class="language-plaintext highlighter-rouge">e</code>” at the beginning of the string with “<code class="language-plaintext highlighter-rouge">XY</code>”. In line 20 we are trying to replace the character “<code class="language-plaintext highlighter-rouge">f</code>” at the beginning of the string with “<code class="language-plaintext highlighter-rouge">XY</code>”.</p>

<p>When you run the previous script you will see the following output in the terminal window.</p>

<pre><code class="language-txt">$ ./index_array_replace_pattern_front_beginning.sh
Content: one two three four five six

Replace first occurrence
${MY_ARRAY[@]/e/X}: onX two thrXe four fivX six
${MY_ARRAY[@]/e*/X}: onX two thrX four fivX six

Replace all occurrences
${MY_ARRAY[@]//e/X}: onX two thrXX four fivX six
${MY_ARRAY[@]//e*/X}: onX two thrX four fivX six

Removal of elements
${MY_ARRAY[@]//e/}: on two thr four fiv six
${MY_ARRAY[@]//f*/}: one two three   six

Replace front-end occurrences of string
${MY_ARRAY[@]/#e/XY}: one two three four five six
${MY_ARRAY[@]/#f/XY}: one two three XYour XYive six
</code></pre>

<p>As you can see from the execution the line 19 from our script will have no effect at all as there is not a single element in the array that begins with the character “<code class="language-plaintext highlighter-rouge">e</code>”. Line 20, however, will affect a couple of elements in the array (elements with values “<code class="language-plaintext highlighter-rouge">four</code>” and “<code class="language-plaintext highlighter-rouge">five</code>”) because they start with the character “<code class="language-plaintext highlighter-rouge">f</code>”.</p>

<p>In the next section we will learn how to replace occurrences of a pattern at the end of a string.</p>

<h4 id="replace-ending-occurrences-of-string"><b>Replace ending occurrences of string</b></h4>

<p>To be able to replace occurrences at the beginning of a string we need to use the following syntax: “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]/%&lt;pattern&gt;/&lt;replacement&gt;}</code>”.</p>

<p>What will happen is that Bash will go element by element and will replace the substring that matches the pattern provided, that is <strong>at the end of the string</strong>, with the replacement provided.</p>

<p>Let’s see how it works with an example by modifying our previous script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: index_array_replace_pattern_back_ending.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="c"># Replace first occurrence</span>
 6 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace first occurrence"</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e/X</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/e*/X</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="c"># Replace all occurrences</span>
10 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace all occurrences"</span>
11 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/X</span><span class="k">}</span><span class="s2">"</span>
12 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e*/X}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e*/X</span><span class="k">}</span><span class="s2">"</span>
13 <span class="c"># Removal of elements</span>
14 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Removal of elements"</span>
15 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//e/}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//e/</span><span class="k">}</span><span class="s2">"</span>
16 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]//f*/}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]//f*/</span><span class="k">}</span><span class="s2">"</span>
17 <span class="c"># Replace front-end occurrences of string</span>
18 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace front-end occurrences of string"</span>
19 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/#e/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/#e/XY</span><span class="k">}</span><span class="s2">"</span>
20 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/#f/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/#f/XY</span><span class="k">}</span><span class="s2">"</span>
21 <span class="c"># Replace back-end occurrences of string</span>
22 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Replace back-end occurrences of string"</span>
23 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/%e/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/%e/XY</span><span class="k">}</span><span class="s2">"</span>
24 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/%our/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/%our/XY</span><span class="k">}</span><span class="s2">"</span>
25 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]/%y/XY}: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]/%y/XY</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>In this case we have added lines 21 to 25 to our script. In line 23 we are trying to replace the character “<code class="language-plaintext highlighter-rouge">e</code>” at the end of the string with “<code class="language-plaintext highlighter-rouge">XY</code>”. In line 24 we are trying to replace the substring “<code class="language-plaintext highlighter-rouge">our</code>” at the end of the string with “<code class="language-plaintext highlighter-rouge">XY</code>”. In line 25 we are trying to replace the character “<code class="language-plaintext highlighter-rouge">y</code>” at the end of the string with “<code class="language-plaintext highlighter-rouge">XY</code>”.</p>

<p>When you run the script you will the following output in your terminal window.</p>

<pre><code class="language-txt">$ ./index_array_replace_pattern_back_ending.sh
Content: one two three four five six

Replace first occurrence
${MY_ARRAY[@]/e/X}: onX two thrXe four fivX six
${MY_ARRAY[@]/e*/X}: onX two thrX four fivX six

Replace all occurrences
${MY_ARRAY[@]//e/X}: onX two thrXX four fivX six
${MY_ARRAY[@]//e*/X}: onX two thrX four fivX six

Removal of elements
${MY_ARRAY[@]//e/}: on two thr four fiv six
${MY_ARRAY[@]//f*/}: one two three   six

Replace front-end occurrences of string
${MY_ARRAY[@]/#e/XY}: one two three four five six
${MY_ARRAY[@]/#f/XY}: one two three XYour XYive six

Replace back-end occurrences of string
${MY_ARRAY[@]/%e/XY}: onXY two threXY four fivXY six
${MY_ARRAY[@]/%our/XY}: one two three fXY five six
${MY_ARRAY[@]/%y/XY}: one two three four five six
</code></pre>

<p>As you can see from the execution the line 23 from our script will affect several elements of the array (the ones with values “<code class="language-plaintext highlighter-rouge">one</code>”, “<code class="language-plaintext highlighter-rouge">three</code>” and “<code class="language-plaintext highlighter-rouge">five</code>” as they all end with the character “<code class="language-plaintext highlighter-rouge">e</code>”).</p>

<p>The line 24 from our script will affect one single element (element with value “<code class="language-plaintext highlighter-rouge">four</code>” as is the only one that ends with the substring “<code class="language-plaintext highlighter-rouge">our</code>”).</p>

<p>Line 25 from our script will not impact any element (as there is no element ending with the character “<code class="language-plaintext highlighter-rouge">y</code>”), leaving the array untouched.</p>

<p>Once that we have seen all the possible ways to do a replacement on an array we will learn how to delete an entire array in the next section.</p>

<h3 id="delete-an-entire-array">Delete an entire array</h3>

<p>In order to delete a whole array we need to use the built-in command “<code class="language-plaintext highlighter-rouge">unset</code>” and the name of the array variable without the dollar sign.</p>

<p>Let’s see it in action with an example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: delete_array.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Content: '</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">'"</span>
 5 <span class="c"># Deleting the array</span>
 6 <span class="nb">unset </span>MY_ARRAY
 7 <span class="nb">echo</span> <span class="s2">"Content after deletion: '</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">'"</span>
</code></pre></div></div>

<p>In the previous script we are declaring an array named “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” on line 3 with 6 elements. Then, on line 6 we are using “<code class="language-plaintext highlighter-rouge">unset</code>” to remove the contents of the whole array. Last, on line 7, the script shows the content of the array after deleting it.</p>

<p>When you run the previous script you will get the following output in your terminal window.</p>

<pre><code class="language-txt">$ ./delete_array.sh
Content: 'one two three four five six'
Content after deletion: ''
</code></pre>

<p>What is basically happening with the deletion is that the variable “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” ceases to exist.</p>

<p>It’s happening the same thing we saw back in Chapter 4 in the section “<a href="http://localhost:4000/bash-in-depth/0004-Variables.html#how-to-delete-declared-variables">How to delete declared variables?</a>”.</p>

<p>In the next section we are going to learn how to consult the length of a specific element of the array.</p>

<h3 id="consult-the-length-of-the-i-th-element-of-the-array">Consult the length of the i-th element of the array</h3>

<p>In a very similar way as we saw on Chapter 5 section “<a href="http://localhost:4000/bash-in-depth/0005-Working-with-Strings.html#string-length">String length</a>” where we used the syntax “<code class="language-plaintext highlighter-rouge">${#myVariable}</code>” to get the length of the string inside the variable named “<code class="language-plaintext highlighter-rouge">myVariable</code>”, for the case of elements of arrays is exactly the same with the difference that we need to provide the position of the element in the array.</p>

<p>This means that we will need to use the syntax “</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[&lt;index&gt;]</span><span class="k">}</span>
</code></pre></div></div>

<p>To get the length of the element with index “<code class="language-plaintext highlighter-rouge">&lt;index&gt;</code>”.</p>

<p>Let’s see how it works with a simple example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_length_ith_element.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">echo</span> <span class="s2">"Length of </span><span class="se">\$</span><span class="s2">{MY_ARRAY[0]}: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[0]</span><span class="k">}</span><span class="s2">"</span>
 5 <span class="nb">echo</span> <span class="s2">"Length of </span><span class="se">\$</span><span class="s2">{MY_ARRAY[1]}: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[1]</span><span class="k">}</span><span class="s2">"</span>
 6 <span class="nb">echo</span> <span class="s2">"Length of </span><span class="se">\$</span><span class="s2">{MY_ARRAY[2]}: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[2]</span><span class="k">}</span><span class="s2">"</span>
 7 <span class="nb">echo</span> <span class="s2">"Length of </span><span class="se">\$</span><span class="s2">{MY_ARRAY[3]}: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[3]</span><span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"Length of </span><span class="se">\$</span><span class="s2">{MY_ARRAY[4]}: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[4]</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="nb">echo</span> <span class="s2">"Length of </span><span class="se">\$</span><span class="s2">{MY_ARRAY[5]}: </span><span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[5]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>In the previous script you will see that on line 3 an array named “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” is declared with six items in it.</p>

<p>The code from line 4 until line 9 will print the length of those items.</p>

<p>When you run the previous script you will see the following output in the terminal window.</p>

<pre><code class="language-txt">$ ./array_length_ith_element.sh
Length of ${MY_ARRAY[0]}: 3
Length of ${MY_ARRAY[1]}: 3
Length of ${MY_ARRAY[2]}: 5
Length of ${MY_ARRAY[3]}: 4
Length of ${MY_ARRAY[4]}: 4
Length of ${MY_ARRAY[5]}: 3
</code></pre>

<p>As you can see from the running of the script, each single line from line 4 to line 9 prints the length of one of the elements in the array.</p>

<p>This works the same way for associative arrays with <strong>the only difference that you will have to use the keys instead of the indices</strong>.</p>

<p>In the next section we are going to learn how to copy arrays.</p>

<h3 id="how-to-copy-an-array">How to copy an array</h3>

<p>In order to copy an array to another variable you need to use the syntax “<code class="language-plaintext highlighter-rouge">(${MY_ARRAY[@]})</code>” and assign it to a variable. Like the following snippet of code.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">MY_ARRAY_COPY</span><span class="o">=(</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s see how it works with a simple example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_copy.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="nb">declare</span> <span class="nt">-p</span> MY_ARRAY
 5 <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Copying MY_ARRAY to MY_ARRAY_COPY</span><span class="se">\n</span><span class="s2">"</span>
 6 <span class="nv">MY_ARRAY_COPY</span><span class="o">=(</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="o">)</span>
 7 MY_ARRAY_COPY+<span class="o">=(</span><span class="s2">"seven"</span><span class="o">)</span>
 8 <span class="nb">echo</span> <span class="s2">"Original array: "</span>
 9 <span class="nb">declare</span> <span class="nt">-p</span> MY_ARRAY
10 <span class="nb">echo</span> <span class="s2">"Copy array:"</span>
11 <span class="nb">declare</span> <span class="nt">-p</span> MY_ARRAY_COPY
</code></pre></div></div>

<p>In the previous script we are declaring an array on line 3 with name “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>”, then we copy it to the new variable “<code class="language-plaintext highlighter-rouge">MY_ARRAY_COPY</code>” on line 6. After copying the array to the new variable, we add a new element on line 7 to the copied array and we show them both to prove that a modification in one of the arrays will not affect the other one.</p>

<p>When you run the previous script you will see the following on your terminal.</p>

<pre><code class="language-txt">$ ./array_copy.sh
declare -a MY_ARRAY=([0]="one" [1]="two" [2]="three" [3]="four" [4]="five" [5]="six")

Copying MY_ARRAY to MY_ARRAY_COPY

Original array: 
declare -a MY_ARRAY=([0]="one" [1]="two" [2]="three" [3]="four" [4]="five" [5]="six")
Copy array:
declare -a MY_ARRAY_COPY=([0]="one" [1]="two" [2]="three" [3]="four" [4]="five" [5]="six" [6]="seven")
</code></pre>

<p>As you can see from the execution the variables “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” and “<code class="language-plaintext highlighter-rouge">MY_ARRAY_COPY</code>” are independent.</p>

<p>In the next section we are going to learn how to take a slice of an array.</p>

<h3 id="slice-of-an-array">Slice of an array</h3>

<p>If we wanted to take a few elements of the array that are in consecutive positions (this is typically called a “<em>slice</em>”) we need to use the syntax “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]:begin:amount}</code>”.</p>

<p>What the previous syntax means is “<em>Starting from the element whose index is <code class="language-plaintext highlighter-rouge">&lt;begin&gt;</code> grab <code class="language-plaintext highlighter-rouge">&lt;amount&gt;</code> elements</em>”.</p>

<p>The values of both “<code class="language-plaintext highlighter-rouge">begin</code>” and “<code class="language-plaintext highlighter-rouge">amount</code>” should be whole non-negative numbers (0, 1, 2, etc). If the value of “<code class="language-plaintext highlighter-rouge">amount</code>” is bigger than the number of elements that remain in the array then only the remaining elements will be selected.</p>

<p>Let’s see how it works with simple example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_slice.sh</span>
 3 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 4 <span class="c"># Original content</span>
 5 <span class="nb">echo</span> <span class="s2">"Content: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
 6 <span class="c"># Slice of three elements</span>
 7 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]:2:3} : </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span>:2:3<span class="k">}</span><span class="s2">"</span>
 8 <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">{MY_ARRAY[@]:2:30} : </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span>:2:30<span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>When you run the previous script you will get the following in your terminal window.</p>

<pre><code class="language-txt">$ ./array_slice.sh
Content: one two three four five six
${MY_ARRAY[@]:2:3} : three four five
${MY_ARRAY[@]:2:30} : three four five six
</code></pre>

<p>Here you can see that first (on line 5 of the script) the full content of the array is printed. Then (on lines 7 and 8 of the script) there are two slices printed.</p>

<p>The first slice begins at the element with index 2 (whose value is “<code class="language-plaintext highlighter-rouge">three</code>”) and grabs 3 elements (the first one included), which results in printing elements with values “<code class="language-plaintext highlighter-rouge">three</code>”, “<code class="language-plaintext highlighter-rouge">four</code>” and “<code class="language-plaintext highlighter-rouge">five</code>”.</p>

<p>The second slice begins at the same element (index 2 with value “<code class="language-plaintext highlighter-rouge">three</code>”). But in this case it tries to grab the next 29 elements as well. As you can see, there are not that many elements in the array and Bash will only show the rest of the elements which are till the last one (element with value “<code class="language-plaintext highlighter-rouge">six</code>”).</p>

<p>In the next section we are going to learn how to concatenate two arrays.</p>

<h3 id="concatenate-arrays">Concatenate arrays</h3>

<p>To concatenate two different arrays we need to use the following syntax.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">MY_ARRAY</span><span class="o">=(</span> ... <span class="o">)</span>
    <span class="nv">MY_ARRAY2</span><span class="o">=(</span> ... <span class="o">)</span>

    <span class="nv">MERGED</span><span class="o">=(</span> <span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY2</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="o">)</span>
</code></pre></div></div>

<p>What is happening in the previous syntax? A new array (“<code class="language-plaintext highlighter-rouge">MERGED</code>”) is being declared that contains the elements of the first array (“<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>”) followed by the elements of the second array (“<code class="language-plaintext highlighter-rouge">MY_ARRAY2</code>”).</p>

<p>Although the previous example is using two different arrays, you can use as many arrays as you want.</p>

<p>Let’s see how it works with a simple example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: array_concatenate.sh</span>
 3 <span class="c"># Declare three different arrays</span>
 4 <span class="nv">MY_ARRAY</span><span class="o">=(</span> one two three four five six <span class="o">)</span>
 5 <span class="nv">MY_ARRAY2</span><span class="o">=(</span> seven eight nine ten eleven twelve <span class="o">)</span>
 6 <span class="nv">MY_ARRAY3</span><span class="o">=(</span> thirteen fourteen fifteen <span class="o">)</span>
 7 <span class="c"># Merge the previous three arrays into one</span>
 8 <span class="nv">MERGED</span><span class="o">=(</span><span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY2</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY3</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="o">)</span>
 9 <span class="c"># Print the content of the new array</span>
10 <span class="nb">echo</span> <span class="s2">"MERGED: </span><span class="k">${</span><span class="nv">MERGED</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>In the previous script we are declaring three different arrays that contain different elements. Then we are merging them into a single array (called “<code class="language-plaintext highlighter-rouge">MERGED</code>”) that contains all of the elements.</p>

<p>When you run the script you get the following.</p>

<pre><code class="language-txt">$ ./array_concatenate.sh
MERGED: one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen
</code></pre>

<p>Once we have seen how to declare arrays and what operations we can do on them, we need to take a look at the next step, which is iterating the arrays, and for this we are going to learn the following types of loop:</p>
<ul>
  <li>For-Loop</li>
  <li>For-Loop (C-style)</li>
  <li>While-Loop</li>
  <li>Until-Loop</li>
</ul>

<h2 id="for-loop">For-Loop</h2>

<p>The “<code class="language-plaintext highlighter-rouge">for-loop</code>“ is a kind of loop that is used to perform actions, a priori, to ALL elements of an array. Its syntax is as follows.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/For-Loop.png" width="450px" />
</div>

<p>A priori, this seems to be easy enough, but there are some details that we need to be aware of, which is how the loop is executed. Once the script is running, Bash will execute the loop in two steps:</p>
<ol>
  <li>Expansion of the <code class="language-plaintext highlighter-rouge">&lt;array&gt;</code> provided</li>
  <li>Execution of the commands with the <code class="language-plaintext highlighter-rouge">&lt;array&gt;</code> expanded</li>
</ol>

<p>Let’s see how to use this for loop with a simple example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-001.sh</span>
 3 <span class="c"># Declaration of the array</span>
 4 <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"Item1"</span> <span class="s2">"Item2"</span> <span class="s2">"Item3"</span><span class="o">)</span>
 5 <span class="c"># Using the for loop to iterate through the array</span>
 6 <span class="k">for </span>item <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do
 </span>7     <span class="nb">echo</span> <span class="s2">"Item: </span><span class="nv">$item</span><span class="s2">"</span>
 8 <span class="k">done</span>
</code></pre></div></div>

<p>Right before the loop executes, the expansion will replace the syntax referencing the array, meaning <code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>, with the actual content of the array resulting in the following.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for </span>item <span class="k">in </span>Item1 Item2 Item3<span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="s2">"Item: </span><span class="nv">$item</span><span class="s2">"</span>
    <span class="k">done</span>
</code></pre></div></div>

<p>When you run the previous script, the following will appear in your terminal window.</p>

<pre><code class="language-txt">$ ./loop-001.sh
Item: Item1
Item: Item2
Item: Item3
</code></pre>

<p>The array expansion has a limitation. What would happen if we have items in the array that contain spaces. Something like the following script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-002.sh</span>
 3 <span class="c"># Declaration of the array</span>
 4 <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"Item 1"</span> <span class="s2">"Item 2"</span> <span class="s2">"Item 3"</span><span class="o">)</span>
 5 <span class="c"># Using the for loop to iterate through the array</span>
 6 <span class="k">for </span>item <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do
 </span>7     <span class="nb">echo</span> <span class="s2">"Item: </span><span class="nv">$item</span><span class="s2">"</span>
 8 <span class="k">done</span>
</code></pre></div></div>

<p>Following the same reasoning as before the for loop would be expanded as the following.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for </span>item <span class="k">in </span>Item 1 Item 2 Item 3<span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="s2">"Item: </span><span class="nv">$item</span><span class="s2">"</span>
    <span class="k">done</span>
</code></pre></div></div>

<p>And will generate the following output in the terminal window.</p>

<pre><code class="language-txt">$ ./loop-002.sh
Item: Item
Item: 1
Item: Item
Item: 2
Item: Item
Item: 3
</code></pre>

<p>How do we tackle this limitation? There are two ways to do it.</p>

<p>The first one (the easiest one) is to wrap the array with double quotes. Resulting in the following script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-003.sh</span>
 3 <span class="c"># Declaration of the array</span>
 4 <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"Item 1"</span> <span class="s2">"Item 2"</span> <span class="s2">"Item 3"</span><span class="o">)</span>
 5 <span class="c"># Using the for loop to iterate through the array</span>
 6 <span class="k">for </span>item <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
 </span>7     <span class="nb">echo</span> <span class="s2">"Item: </span><span class="nv">$item</span><span class="s2">"</span>
 8 <span class="k">done</span>
</code></pre></div></div>

<p>Please notice how, on line 6, the array “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” is wrapped between double quotes. Now when you run the previous script you will get the following result.</p>

<pre><code class="language-txt">$ ./loop-003.sh
Item: Item 1
Item: Item 2
Item: Item 3
</code></pre>

<p>The second way is by using the C-style for loop which we will learn in the next section.</p>

<p>But right before going to the next section I would like to come back to what we discussed back in section “<a href="http://localhost:4000/bash-in-depth/0012-Arrays-and-loops.html#get-the-whole-content-of-the-array">Get the whole content of the array</a>”. In that section we talked about the two ways to get the contents of the array being “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” and “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>”.</p>

<p>We are already very familiar with the second way (“<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>”). What happens if we use one of the previous scripts and use “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” instead of “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[@]}</code>”?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-004.sh</span>
 3 <span class="c"># Declaration of the array</span>
 4 <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"Item 1"</span> <span class="s2">"Item 2"</span> <span class="s2">"Item 3"</span><span class="o">)</span>
 5 <span class="c"># Using the for loop to iterate through the array</span>
 6 <span class="k">for </span>item <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
 </span>7     <span class="nb">echo</span> <span class="s2">"Item: </span><span class="nv">$item</span><span class="s2">"</span>
 8 <span class="k">done</span>
</code></pre></div></div>

<p>As you can see in the previous script the only change that was done is on line 6. When you run the previous script you will get the following result.</p>

<pre><code class="language-txt">$ ./loop-004.sh
Item: Item 1 Item 2 Item 3
</code></pre>

<p>As you can see from the execution of the script only one single item was printed. The reason for this is because with “<code class="language-plaintext highlighter-rouge">${MY_ARRAY[*]}</code>” the whole content of the array will be printed as a single string. As it’s one single string the for-loop will interpret it as an array of a single element.</p>

<p>Now that we have wrapped this topic we will proceed to the next section to learn about C-style For-loops.</p>

<h2 id="for-loop-c-style">For-Loop (C-style)</h2>

<p>In this case, we are going to work mainly with indices (integer numbers) and the length of the array.<a id="footnote-2-ref" href="#footnote-2" style="font-size:x-small">[2]</a> This kind of loop has the following structure.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/For-Loop-C-Style.png" width="700px" />
</div>

<p>Notice the double parenthesis <code class="language-plaintext highlighter-rouge">((...))</code>, which allows us to work with integer numbers as we saw previously in <a href="http://localhost:4000/bash-in-depth/0006-Working-with-Numbers-Integers.html#compound-command-">Chapter 6</a>.</p>

<p>The way it works is as follows:</p>
<ol>
  <li>“<code class="language-plaintext highlighter-rouge">&lt;init&gt;</code>” is executed setting the needed variables</li>
  <li>“<code class="language-plaintext highlighter-rouge">&lt;stop-condition&gt;</code>“ is evaluated to check whether the execution of commands has to be done or not. If the result of the condition is “<code class="language-plaintext highlighter-rouge">true</code>” it will go to step 3. Otherwise, it will go to step 6.</li>
  <li>“<code class="language-plaintext highlighter-rouge">&lt;commands&gt;</code>“ are executed. This is the actual logic of the loop and can contain any of the statements we have already seen (variable declarations, other loops, if-else statements, etc)</li>
  <li>“<code class="language-plaintext highlighter-rouge">&lt;next-step&gt;</code>“ is executed, preparing the execution for the next iteration of the loop. Typically what happens in this step is that the index that was created in step 1 gets incremented.</li>
  <li>Go to step 2.</li>
  <li>End of loop.</li>
</ol>

<p>Let’s see how this kind of loop works with a simple example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-005.sh</span>
 3 <span class="c"># Declaration of an array</span>
 4 <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span><span class="s2">"Item 1"</span> <span class="s2">"Item 2"</span> <span class="s2">"Item 3"</span><span class="o">)</span>
 5 <span class="c"># Loop iterating through elements of the array</span>
 6 <span class="k">for</span> <span class="o">((</span>i <span class="o">=</span> 0<span class="p">;</span> i &lt; <span class="k">${#</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> i++<span class="o">))</span>
 7 <span class="k">do
 </span>8     <span class="nb">echo</span> <span class="s2">"MY_ARRAY[</span><span class="nv">$i</span><span class="s2">]: </span><span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span>
 9 <span class="k">done</span>
</code></pre></div></div>

<p>When you run the previous script you will get the following result in the terminal window.</p>

<pre><code class="language-txt">$ ./loop-005.sh
MY_ARRAY[0]: Item 1
MY_ARRAY[1]: Item 2
MY_ARRAY[2]: Item 3
</code></pre>

<p>In the following section we will learn about the “<code class="language-plaintext highlighter-rouge">while</code>” loop.</p>

<h2 id="while-loop">While loop</h2>

<p>This kind of loop will execute a list of commands as long as a condition evaluates to true. The shape of this loop is as follows.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/While-Loop.png" width="550px" />
</div>

<p>As you can imagine, the “<code class="language-plaintext highlighter-rouge">condition</code>” is an expression like we saw in the <a href="http://localhost:4000/bash-in-depth/0010-If-statement.html#how-to-test-stuff">Chapter dedicated to IF-ELSE</a>, so we can use “<code class="language-plaintext highlighter-rouge">test</code>”, “<code class="language-plaintext highlighter-rouge">[...]</code>” or “<code class="language-plaintext highlighter-rouge">[[...]]</code>”. Let’s see some examples in the following script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-006.sh</span>
 3 <span class="c"># Init a counter</span>
 4 <span class="nv">i</span><span class="o">=</span>0
 5 <span class="c"># Single bracket operator</span>
 6 <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> <span class="nt">-lt</span> 4 <span class="o">]</span><span class="p">;</span> <span class="k">do
 </span>7     <span class="nb">echo</span> <span class="s2">"Line#</span><span class="nv">$i</span><span class="s2">"</span>
 8     <span class="nv">i</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
 9 <span class="k">done
</span>10 <span class="c"># Separation and reset counter</span>
11 <span class="nb">echo</span> <span class="s2">"----------"</span>
12 <span class="nv">i</span><span class="o">=</span>0
13 <span class="c"># test operator</span>
14 <span class="k">while </span><span class="nb">test</span> <span class="nv">$i</span> <span class="nt">-lt</span> 5<span class="p">;</span> <span class="k">do
</span>15     <span class="nb">echo</span> <span class="s2">"Line#</span><span class="nv">$i</span><span class="s2">"</span>
16     <span class="nv">i</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
17 <span class="k">done
</span>18 <span class="c"># Separation and reset counter</span>
19 <span class="nb">echo</span> <span class="s2">"----------"</span>
20 <span class="nv">i</span><span class="o">=</span>0
21 <span class="c"># Double bracket</span>
22 <span class="k">while</span> <span class="o">[[</span> <span class="nv">$i</span> &lt; 6 <span class="o">]]</span><span class="p">;</span> <span class="k">do
</span>23     <span class="nb">echo</span> <span class="s2">"Line#</span><span class="nv">$i</span><span class="s2">"</span>
24     <span class="nv">i</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
25 <span class="k">done</span>
</code></pre></div></div>

<p>When you run the previous script you will see the following output in your terminal window.</p>

<pre><code class="language-txt">$ ./loop-006.sh
Line#0
Line#1
Line#2
Line#3
----------
Line#0
Line#1
Line#2
Line#3
Line#4
----------
Line#0
Line#1
Line#2
Line#3
Line#4
Line#5
</code></pre>

<p>In the following section we will learn about the “<code class="language-plaintext highlighter-rouge">until</code>” loop.</p>

<h2 id="until-loop">Until loop</h2>

<p>This kind of loop will execute a list of commands as long as a condition evaluates to false. The shape of this loop is as follows.</p>

<div style="text-align:center">
    <img src="/assets/bash-in-depth/0012-Arrays-and-loops/Until-Loop.png" width="550px" />
</div>

<p>This kind of loop is similar to the previous “<code class="language-plaintext highlighter-rouge">while</code>” loop in the sense that it will execute the commands in its body as long as the condition has a specific value.</p>

<p>In the previous “<code class="language-plaintext highlighter-rouge">while</code>” loop, the execution continued <strong>while the condition was true</strong>. At the moment of having the condition evaluated to false, the loop would stop.</p>

<p>In this “<code class="language-plaintext highlighter-rouge">until</code>” loop, the execution of the commands in its body will continue <strong>until the condition evaluates to true</strong> (so the condition <strong>must be FALSE for this loop to execute</strong>). At the moment of having the condition evaluated to true, the loop will stop.</p>

<p>Let’s see how it works with the following example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-007.sh</span>
 3 <span class="c"># Initialize counter</span>
 4 <span class="nv">i</span><span class="o">=</span>0
 5 <span class="c"># Using the single bracket operator</span>
 6 <span class="k">until</span> <span class="o">[</span> <span class="nv">$i</span> <span class="nt">-gt</span> 4 <span class="o">]</span><span class="p">;</span> <span class="k">do
 </span>7     <span class="nb">echo</span> <span class="s2">"Line#</span><span class="nv">$i</span><span class="s2">"</span>
 8     <span class="nv">i</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
 9 <span class="k">done
</span>10 <span class="c"># Separator and re-initialize the counter</span>
11 <span class="nb">echo</span> <span class="s2">"----------"</span>
12 <span class="nv">i</span><span class="o">=</span>0
13 <span class="c"># Using the test operator</span>
14 <span class="k">until </span><span class="nb">test</span> <span class="nv">$i</span> <span class="nt">-gt</span> 5<span class="p">;</span> <span class="k">do
</span>15     <span class="nb">echo</span> <span class="s2">"Line#</span><span class="nv">$i</span><span class="s2">"</span>
16     <span class="nv">i</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
17 <span class="k">done
</span>18 <span class="c"># Separator and re-initialize the counter</span>
19 <span class="nb">echo</span> <span class="s2">"----------"</span>
20 <span class="nv">i</span><span class="o">=</span>0
21 <span class="c"># Using the double bracket operator</span>
22 <span class="k">until</span> <span class="o">[[</span> <span class="nv">$i</span> <span class="o">&gt;</span> 6 <span class="o">]]</span><span class="p">;</span> <span class="k">do
</span>23     <span class="nb">echo</span> <span class="s2">"Line#</span><span class="nv">$i</span><span class="s2">"</span>
24     <span class="nv">i</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
25 <span class="k">done</span>
</code></pre></div></div>

<p>When you run the previous script you will see the following output in the terminal window.</p>

<pre><code class="language-txt">$ ./loop-007.sh
Line#0
Line#1
Line#2
Line#3
Line#4
----------
Line#0
Line#1
Line#2
Line#3
Line#4
Line#5
----------
Line#0
Line#1
Line#2
Line#3
Line#4
Line#5
Line#6
</code></pre>

<p>We have learnt how to create loops in different ways. There are times on which we will want to control the execution of the loop to either skip the current iteration and go to the following one, or just end the execution of the loop.</p>

<p>This control is done with the keywords “<code class="language-plaintext highlighter-rouge">continue</code>” and “<code class="language-plaintext highlighter-rouge">break</code>”. Those are what we are going to learn next… :)</p>

<h2 id="continue-and-break"><code class="language-plaintext highlighter-rouge">continue</code> and <code class="language-plaintext highlighter-rouge">break</code></h2>

<p>There are times on which we will need to modify the execution of the current loop being executed to either stop it or just cut it short. For that we do have the following keywords that will help us:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">break</code></li>
  <li><code class="language-plaintext highlighter-rouge">continue</code></li>
</ul>

<p>“<code class="language-plaintext highlighter-rouge">break</code>” is used to stop the execution of the current loop and to continue with the program.</p>

<p>Let’s see how it works with the following example script.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-008.sh</span>
 3 <span class="c"># Declaration of array</span>
 4 <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">MY_ARRAY</span><span class="o">=(</span>1 2 3 4 5 6 7 8 9 10<span class="o">)</span>
 5 <span class="c"># For-loop that iterates through the array</span>
 6 <span class="k">for </span>item <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do
 </span>7 		<span class="c"># Condition to exit on item with value 5</span>
 8     <span class="k">if</span> <span class="o">[</span> <span class="nv">$item</span> <span class="nt">-eq</span> 5 <span class="o">]</span><span class="p">;</span> <span class="k">then
 </span>9         <span class="nb">echo</span> <span class="s2">"Exiting loop on item '</span><span class="nv">$item</span><span class="s2">'"</span>
10         <span class="nb">break
</span>11     <span class="k">fi
</span>12     <span class="nb">echo</span> <span class="s2">"Current item: </span><span class="nv">$item</span><span class="s2">"</span>
13 <span class="k">done</span>
</code></pre></div></div>

<p>This was a very basic example. In this case, the loop will iterate over the items of “<code class="language-plaintext highlighter-rouge">MY_ARRAY</code>” until the condition matches, in that case it will break the current loop.</p>

<p>When you execute the previous script you get the following result.</p>

<pre><code class="language-txt">$ ./loop-008.sh
Current item: 1
Current item: 2
Current item: 3
Current item: 4
Exiting loop on item '5'
</code></pre>

<p>But “<code class="language-plaintext highlighter-rouge">break</code>” can also be invoked with an argument (“<code class="language-plaintext highlighter-rouge">break n</code>”, being “<code class="language-plaintext highlighter-rouge">n</code>” an integer bigger or equal to 1). If this extra parameter is included, it will stop the execution of the “<code class="language-plaintext highlighter-rouge">n</code>” enclosing loops.</p>

<p>Let’s see how it works with an example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-009.sh</span>
 3 <span class="c"># Declaring a couple of arrays</span>
 4 <span class="nv">MY_ARRAY1</span><span class="o">=(</span> 1 2 3 4 5 6 7 8 9 10 <span class="o">)</span>
 5 <span class="nv">MY_ARRAY2</span><span class="o">=(</span> a b c e f g h i j k <span class="o">)</span>
 6 <span class="c"># For-loops iterating through both arrays</span>
 7 <span class="k">for </span>item1 <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY1</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span> <span class="c"># loop-1</span>
 8     <span class="nb">echo</span> <span class="s2">"Item1: </span><span class="nv">$item1</span><span class="s2">"</span>
 9     <span class="k">for </span>item2 <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY2</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span> <span class="c"># loop-2</span>
10         <span class="nb">echo</span> <span class="s2">"Item2: </span><span class="nv">$item2</span><span class="s2">"</span>
11 		   <span class="c"># Exiting both loops when item1 is 5 and item2 is e</span>
12         <span class="k">if</span> <span class="o">[</span> <span class="nv">$item1</span> <span class="nt">-eq</span> 5 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nv">$item2</span> <span class="o">=</span> <span class="s1">'e'</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
</span>13             <span class="nb">echo</span> <span class="s2">"Exiting both loops on items '</span><span class="nv">$item1</span><span class="s2">' and '</span><span class="nv">$item2</span><span class="s2">'"</span>
14             <span class="nb">break </span>2 <span class="c"># Exiting both loop-1 and loop-2</span>
15         <span class="k">fi
</span>16     <span class="k">done
</span>17     <span class="nb">echo</span> <span class="s2">"Ending execution of loop-1"</span>
18 <span class="k">done</span>
</code></pre></div></div>

<p>When you execute the previous script you will the following in the terminal window.</p>

<pre><code class="language-txt">$ ./loop-009.sh
Item1: 1
Item2: a
Item2: b
Item2: c
Item2: e
Item2: f
Item2: g
Item2: h
Item2: i
Item2: j
Item2: k
Ending execution of loop-1
Item1: 2
Item2: a
Item2: b
Item2: c
Item2: e
Item2: f
Item2: g
Item2: h
Item2: i
Item2: j
Item2: k
Ending execution of loop-1
Item1: 3
Item2: a
Item2: b
Item2: c
Item2: e
Item2: f
Item2: g
Item2: h
Item2: i
Item2: j
Item2: k
Ending execution of loop-1
Item1: 4
Item2: a
Item2: b
Item2: c
Item2: e
Item2: f
Item2: g
Item2: h
Item2: i
Item2: j
Item2: k
Ending execution of loop-1
Item1: 5
Item2: a
Item2: b
Item2: c
Item2: e
Exiting both loops on items '5' and 'e'
</code></pre>

<p>If the number specified as an extra parameter is bigger than the number of levels of loop, it will just stop the execution of the maximum number of loops and nothing will break.</p>

<p>“<code class="language-plaintext highlighter-rouge">continue</code>”  is the other keyword to know to operate in the loops. This keyword is used for when you want to stop the current iteration of the loop and jump to the next one.</p>

<p>Let’s see an example to better understand how it works.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-010.sh</span>
 3 <span class="c"># Declaring a couple of arrays</span>
 4 <span class="nv">MY_ARRAY1</span><span class="o">=(</span> 1 2 3 4 5 6 7 8 9 10 <span class="o">)</span>
 5 <span class="nv">MY_ARRAY2</span><span class="o">=(</span> a b c d e f g h i j <span class="o">)</span>
 6 <span class="c"># For-loop iterating through both arrays</span>
 7 <span class="k">for </span>item1 <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY1</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span> <span class="c"># loop-1</span>
 8     <span class="nb">echo</span> <span class="s2">"Item1: </span><span class="nv">$item1</span><span class="s2">"</span>
 9     <span class="k">for </span>item2 <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY2</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span> <span class="c"># loop-2</span>
10         <span class="nb">echo</span> <span class="s2">"Item2: </span><span class="nv">$item2</span><span class="s2">"</span>
11         <span class="c"># Jumping to the next iteration of inner loop</span>
12         <span class="k">if</span> <span class="o">[</span> <span class="nv">$item2</span> <span class="o">=</span> <span class="s2">"d"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nv">$item1</span> <span class="nt">-eq</span> 5 <span class="o">]</span><span class="p">;</span> <span class="k">then
</span>13             <span class="nb">echo</span> <span class="s2">"Jumping on 'd' and '5'"</span>
14             <span class="k">continue
</span>15         <span class="k">fi
</span>16         <span class="nb">echo</span> <span class="s2">"End Item2"</span>
17     <span class="k">done
</span>18     <span class="nb">echo</span> <span class="s2">"End Item1"</span>
19 <span class="k">done</span>
</code></pre></div></div>

<p>When you run the previous script you will get the following result in the terminal window.</p>

<pre><code class="language-txt">$ ./loop-010.sh
Item1: 1
Item2: a
End Item2
Item2: b
End Item2
Item2: c
End Item2
Item2: d
End Item2
Item2: e
End Item2
Item2: f
End Item2
Item2: g
End Item2
...
End Item2
Item2: b
End Item2
Item2: c
End Item2
Item2: d
Jumping on 'd' and '5'
Item2: e
End Item2
...
End Item2
Item2: e
End Item2
Item2: f
End Item2
Item2: g
End Item2
Item2: h
End Item2
Item2: i
End Item2
Item2: j
End Item2
End Item1
</code></pre>

<p>Similar to “<code class="language-plaintext highlighter-rouge">break</code>”, “<code class="language-plaintext highlighter-rouge">continue</code>” is able to accept an extra parameter which will skip the execution of the loop “<code class="language-plaintext highlighter-rouge">n</code>” levels above. Let’s see how it works with the following script as an example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 <span class="c">#!/usr/bin/env bash</span>
 2 <span class="c">#Script: loop-011.sh</span>
 3 <span class="c"># Declaring a couple of arrays</span>
 4 <span class="nv">MY_ARRAY1</span><span class="o">=(</span> 1 2 3 4 5 6 7 8 9 10 <span class="o">)</span>
 5 <span class="nv">MY_ARRAY2</span><span class="o">=(</span> a b c d e f g h i j <span class="o">)</span>
 6 <span class="c"># For-loops iterating through the arrays</span>
 7 <span class="k">for </span>item1 <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY1</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span> <span class="c"># loop-1</span>
 8     <span class="nb">echo</span> <span class="s2">"Item1: </span><span class="nv">$item1</span><span class="s2">"</span>
 9     <span class="k">for </span>item2 <span class="k">in</span> <span class="k">${</span><span class="nv">MY_ARRAY2</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span> <span class="c"># loop-2</span>
10         <span class="nb">echo</span> <span class="s2">"Item2: </span><span class="nv">$item2</span><span class="s2">"</span>
11         <span class="c"># Continue to next iteration of the outer loop</span>
12 				<span class="c"># when item1 is 5 and item2 is d</span>
13         <span class="k">if</span> <span class="o">[</span> <span class="nv">$item2</span> <span class="o">=</span> <span class="s2">"d"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nv">$item1</span> <span class="nt">-eq</span> 5 <span class="o">]</span><span class="p">;</span> <span class="k">then
</span>14             <span class="nb">echo</span> <span class="s2">"Jumping on 'd' and '5'"</span>
15             <span class="k">continue </span>2 <span class="c"># go to next iteration of loop-1</span>
16         <span class="k">fi
</span>17         <span class="nb">echo</span> <span class="s2">"End Item2"</span>
18     <span class="k">done
</span>19     <span class="nb">echo</span> <span class="s2">"End Item1"</span>
20 <span class="k">done</span>
</code></pre></div></div>

<p>When you run the previous script you get the following result.</p>

<pre><code class="language-txt">$ ./loop-011.sh
Item1: 1
Item2: a
End Item2
Item2: b
End Item2
Item2: c
End Item2
Item2: d
End Item2
Item2: e
End Item2
...
End Item1
Item1: 5
Item2: a
End Item2
Item2: b
End Item2
Item2: c
End Item2
Item2: d
Jumping on 'd' and '5'
Item1: 6
Item2: a
End Item2
...
End Item2
Item2: h
End Item2
Item2: i
End Item2
Item2: j
End Item2
End Item1
</code></pre>

<p>Same as with “<code class="language-plaintext highlighter-rouge">break</code>” you should provide an integer number that is bigger or equal to 1. If the number provided is larger than the level of loops, the outer loop will be skipped.</p>

<h2 id="summary">Summary</h2>

<p>In this chapter we learnt a lot about the different kinds of arrays and how to iterate them.</p>

<p>We learnt what indexed and associative arrays are and the differences between them.</p>

<p>We learnt what are the different operations that can be applied to the arrays (like adding elements, getting slices of the arrays, adding new elements, removing elements knowing the index or the pattern and so much more).</p>

<p>Then we learnt how to iterate through the arrays with different kinds of loops like the for-loops, the for-loops with C-style, while-loops and until-loops.</p>

<p>After the loops we learnt how to control the flow within the loops by using the “<code class="language-plaintext highlighter-rouge">continue</code>” and “<code class="language-plaintext highlighter-rouge">break</code>” key words.</p>

<p>Last, but not least, we learnt how to use associative arrays to be used as sets.</p>

<p>This was a lot of content. My recommendation for you is to practice to test the limits of your understanding.</p>

<h2 id="references">References</h2>
<ol>
  <li><a href="https://linuxhint.com/associative_arrays_bash_examples/">https://linuxhint.com/associative_arrays_bash_examples/</a></li>
  <li><a href="https://ostechnix.com/bash-indexed-array/">https://ostechnix.com/bash-indexed-array/</a></li>
  <li><a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-loops.php">https://ryanstutorials.net/bash-scripting-tutorial/bash-loops.php</a></li>
  <li><a href="https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html">https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html</a></li>
  <li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_05.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_05.html</a></li>
  <li><a href="https://unix.stackexchange.com/questions/417292/bash-for-loop-without-a-in-foo-bar-part">https://unix.stackexchange.com/questions/417292/bash-for-loop-without-a-in-foo-bar-part</a></li>
  <li><a href="https://unix.stackexchange.com/questions/746480/what-is-difference-between-these-two-declarations-of-associative-arrays-in-bash/">https://unix.stackexchange.com/questions/746480/what-is-difference-between-these-two-declarations-of-associative-arrays-in-bash/</a></li>
  <li><a href="https://www.gnu.org/software/bash/manual/html_node/Arrays.html">https://www.gnu.org/software/bash/manual/html_node/Arrays.html</a></li>
  <li><a href="https://www.shell-tips.com/bash/arrays/#gsc.tab=0">https://www.shell-tips.com/bash/arrays/#gsc.tab=0</a></li>
</ol>

<hr style="width:100%;text-align:center;margin-left:0;margin-bottom:10px;" />

<p id="footnote-1" style="font-size:10pt">
1. Up to thre reader to give it a try.<a href="#footnote-1-ref">&#8617;</a>
</p>
<p id="footnote-2" style="font-size:10pt">
2. <code>${#MY_ARRAY}</code>.<a href="#footnote-2-ref">&#8617;</a>
</p>


</div>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The Engineering Corner</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">The Engineering Corner</li><li><a class="u-email" href="mailto:the.engineering.corner.314@gmail.com">the.engineering.corner.314@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I hope you will have fun and learn new things reading this blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
